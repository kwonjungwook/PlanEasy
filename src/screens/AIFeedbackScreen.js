// src/screens/AIFeedbackScreen.js
import { Ionicons } from "@expo/vector-icons";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { format } from "date-fns";
import { StatusBar } from "expo-status-bar";
import { useEffect, useRef, useState } from "react";
import {
  Alert,
  Animated,
  AppState,
  Keyboard,
  KeyboardAvoidingView,
  Platform,
  SafeAreaView,
  ScrollView,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from "react-native";
import { usePlanner } from "../context/PlannerContext";
import {
  getRecentAnalysisResults,
  getUserContext,
  getYesterdayAnalysisResult,
  saveAnalysisResult,
  saveUserContext,
  testDeepSeekAPI,
} from "../services/ImprovedFeedbackService";

const AIFeedbackScreen = () => {
  const [inputText, setInputText] = useState("");
  const [keyboardHeight, setKeyboardHeight] = useState(0);
  const [isStarted, setIsStarted] = useState(false);
  const [userContext, setUserContext] = useState(null);

  // 1Ïùº 1Ìöå Ï†úÌïú ÏÉÅÌÉú
  const [hasAnalyzedToday, setHasAnalyzedToday] = useState(false);
  const [currentDate, setCurrentDate] = useState(
    format(new Date(), "yyyy-MM-dd")
  );

  // ÌîÑÎ°úÌïÑ ÏàòÏßë ÏÉÅÌÉú
  const [profileStep, setProfileStep] = useState(0);
  const [isCollectingProfile, setIsCollectingProfile] = useState(false);
  const [profileData, setProfileData] = useState({});
  const [showAnalysisScreen, setShowAnalysisScreen] = useState(false);
  const [analysisInput, setAnalysisInput] = useState("");
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [analysisResult, setAnalysisResult] = useState(null);

  const [yesterdayResult, setYesterdayResult] = useState(null);
  const [recentResults, setRecentResults] = useState([]);
  const [selectedResultIndex, setSelectedResultIndex] = useState(0);

  const [isInputMode, setIsInputMode] = useState(false);
  const slideAnim = useRef(new Animated.Value(0)).current;
  const [showProfileScreen, setShowProfileScreen] = useState(false);
  const [editingField, setEditingField] = useState(null);
  const [editValue, setEditValue] = useState("");

  // üÜï Ïò§Î•ò ÏÉÅÌÉú Ï∂îÍ∞Ä
  const [error, setError] = useState(null);
  const [isRetrying, setIsRetrying] = useState(false);

  // üÜï ÏûêÏ†ï Ï≤¥ÌÅ¨Ïö© ÌÉÄÏù¥Î®∏
  const midnightTimerRef = useRef(null);
  const appStateRef = useRef(AppState.currentState);

  // üÜï Ïã§ÏãúÍ∞Ñ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥
  const [timeRemaining, setTimeRemaining] = useState("");
  const countdownTimerRef = useRef(null);

  const scrollViewRef = useRef(null);
  const inputScrollViewRef = useRef(null);

  const {
    schedules,
    tasks,
    studySessions,
    goalTargets,
    weeklyStats,
    monthlyStats,
  } = usePlanner();

  // üÜï ÏûÑÏãú Ï†ÄÏû• ÌÇ§
  const TEMP_PROFILE_KEY = "@temp_profile_data";

  // üÜï Í∞úÏÑ†Îêú ÌîÑÎ°úÌïÑ ÏßàÎ¨∏Îì§ (ÌïôÍµê/Ï†ÑÍ≥µ Ï†úÍ±∞, ÏÑ±Î≥Ñ ÏòµÏÖò Î≥ÄÍ≤Ω)
  const profileQuestions = [
    {
      key: "name",
      question: "Ïù¥Î¶ÑÏù¥ÎÇò ÎãâÎÑ§ÏûÑÏùÑ ÏïåÎ†§Ï£ºÏÑ∏Ïöî!",
      type: "text",
      validation: (value) => value.trim().length > 0,
      errorMsg: "Ïù¥Î¶ÑÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.",
    },
    {
      key: "age",
      question: "ÎÇòÏù¥Î•º ÏïåÎ†§Ï£ºÏã§ Ïàò ÏûàÎÇòÏöî?",
      type: "text",
      validation: (value) => {
        const num = parseInt(value.trim());
        return !isNaN(num) && num > 0 && num < 150;
      },
      errorMsg: "Ïò¨Î∞îÎ•∏ ÎÇòÏù¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî. (1-149)",
    },
    {
      key: "gender",
      question: "ÏÑ±Î≥ÑÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî!",
      type: "buttons",
      options: ["ÎÇ®ÏÑ±", "Ïó¨ÏÑ±"],
    },
    {
      key: "occupation",
      question: "ÌòÑÏû¨ Ïñ¥Îñ§ ÏùºÏùÑ ÌïòÍ≥† Í≥ÑÏÑ∏Ïöî?",
      type: "text",
      validation: (value) => value.trim().length > 0,
      errorMsg: "ÌòÑÏû¨ ÏÉÅÌô©ÏùÑ ÏïåÎ†§Ï£ºÏÑ∏Ïöî.",
    },
    {
      key: "personality",
      question: "Î≥∏Ïù∏Ïùò ÏÑ±Í≤©Ïù¥ÎÇò MBTIÍ∞Ä ÏûàÎã§Î©¥ ÏïåÎ†§Ï£ºÏÑ∏Ïöî!",
      type: "text",
      placeholder: "Ïòà: ENFP, Ïô∏Ìñ•Ï†Å, ÍººÍººÌï® Îì± (ÏÑ†ÌÉùÏÇ¨Ìï≠)",
    },
    {
      key: "goal",
      question: "ÌòÑÏû¨ Í∞ÄÏû• Ï§ëÏöîÌïú Î™©ÌëúÍ∞Ä ÏûàÎÇòÏöî?",
      type: "text",
      placeholder: "Ïòà: ÌÜ†Ïùµ 900Ï†ê, Ï∑®ÏóÖ Ï§ÄÎπÑ Îì± (ÏÑ†ÌÉùÏÇ¨Ìï≠)",
    },
    {
      key: "studyStyle",
      question: "Ïñ¥Îñ§ ÌïôÏäµ Ïä§ÌÉÄÏùºÏùÑ ÏÑ†Ìò∏ÌïòÏãúÎÇòÏöî?",
      type: "buttons",
      options: [
        { label: "Î™∞ÏûÖÌòï - Ìïú Í∞ÄÏßÄÏóê ÏßëÏ§ë", value: "intensive" },
        { label: "Î∂ÑÏÇ∞Ìòï - Ïó¨Îü¨ Í≥ºÎ™© Î≤àÍ∞àÏïÑ", value: "distributed" },
        { label: "Í∑†ÌòïÌòï - ÏùºÍ≥º ÌïôÏäµÏùò Ï°∞Ìôî", value: "balanced" },
      ],
    },
  ];

  // üÜï Ïã§ÏãúÍ∞Ñ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÏóÖÎç∞Ïù¥Ìä∏
  const updateCountdown = () => {
    if (!hasAnalyzedToday) {
      setTimeRemaining("");
      return;
    }

    const now = new Date();
    const midnight = new Date();
    midnight.setHours(24, 0, 0, 0);
    const diff = midnight.getTime() - now.getTime();

    if (diff <= 0) {
      setTimeRemaining("");
      checkAndUpdateDailyLimit();
      return;
    }

    const hours = Math.floor(diff / (1000 * 60 * 60));
    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
    const seconds = Math.floor((diff % (1000 * 60)) / 1000);

    setTimeRemaining(`${hours}ÏãúÍ∞Ñ ${minutes}Î∂Ñ ${seconds}Ï¥à`);
  };

  // üÜï Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌÉÄÏù¥Î®∏ ÏãúÏûë
  const startCountdownTimer = () => {
    if (countdownTimerRef.current) {
      clearInterval(countdownTimerRef.current);
    }

    updateCountdown();
    countdownTimerRef.current = setInterval(updateCountdown, 1000);
  };

  // üÜï Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ ÌÉÄÏù¥Î®∏ Ï†ïÏßÄ
  const stopCountdownTimer = () => {
    if (countdownTimerRef.current) {
      clearInterval(countdownTimerRef.current);
      countdownTimerRef.current = null;
    }
  };

  // üÜï ÏûêÏ†ïÍπåÏßÄ ÎÇ®ÏùÄ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
  const getTimeUntilMidnight = () => {
    const now = new Date();
    const midnight = new Date();
    midnight.setHours(24, 0, 0, 0); // Îã§Ïùå ÎÇ† 0Ïãú
    return midnight.getTime() - now.getTime();
  };

  // üÜï ÏûêÏ†ï ÌÉÄÏù¥Î®∏ ÏÑ§Ï†ï
  const setupMidnightTimer = () => {
    if (midnightTimerRef.current) {
      clearTimeout(midnightTimerRef.current);
    }

    const timeUntilMidnight = getTimeUntilMidnight();

    midnightTimerRef.current = setTimeout(() => {
      console.log("üïõ ÏûêÏ†ïÏù¥ ÎêòÏñ¥ AI Î∂ÑÏÑù Ï†úÌïúÏù¥ Ï¥àÍ∏∞ÌôîÎê©ÎãàÎã§.");
      checkAndUpdateDailyLimit();
      // Îã§Ïùå ÏûêÏ†ïÏùÑ ÏúÑÌïú ÌÉÄÏù¥Î®∏ Ïû¨ÏÑ§Ï†ï
      setupMidnightTimer();
    }, timeUntilMidnight);

    console.log(
      `‚è∞ ÏûêÏ†ï ÌÉÄÏù¥Î®∏ ÏÑ§Ï†ïÎê®: ${Math.round(
        timeUntilMidnight / 1000 / 60
      )}Î∂Ñ ÌõÑ Ï¥àÍ∏∞Ìôî`
    );
  };

  // üÜï ÎÇ†Ïßú Î≥ÄÍ≤Ω Ï≤¥ÌÅ¨ Î∞è Ï†úÌïú ÏóÖÎç∞Ïù¥Ìä∏
  const checkAndUpdateDailyLimit = async () => {
    const today = format(new Date(), "yyyy-MM-dd");

    if (currentDate !== today) {
      console.log(`üìÖ ÎÇ†Ïßú Î≥ÄÍ≤Ω Í∞êÏßÄ: ${currentDate} ‚Üí ${today}`);
      setCurrentDate(today);

      // ÏÉàÎ°úÏö¥ ÎÇ†ÏßúÏùò Î∂ÑÏÑù Ïó¨Î∂Ä Ï≤¥ÌÅ¨
      const todayAnalysis = await hasAnalysisToday();
      setHasAnalyzedToday(todayAnalysis);

      console.log(
        `üîÑ AI Î∂ÑÏÑù ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏: ${todayAnalysis ? "ÏÇ¨Ïö©ÏôÑÎ£å" : "ÏÇ¨Ïö©Í∞ÄÎä•"}`
      );
    }
  };

  // üÜï Ïï± ÏÉÅÌÉú Î≥ÄÍ≤Ω Í∞êÏßÄ
  const handleAppStateChange = (nextAppState) => {
    if (appStateRef.current === "background" && nextAppState === "active") {
      console.log("üì± Ïï±Ïù¥ Ìè¨Í∑∏ÎùºÏö¥ÎìúÎ°ú ÎèåÏïÑÏò¥ - ÎÇ†Ïßú Ï≤¥ÌÅ¨");
      checkAndUpdateDailyLimit();
    }
    appStateRef.current = nextAppState;
  };

  // üÜï ÏûÑÏãú Ï†ÄÏû• Ìï®Ïàò
  const saveTempProfile = async (stepData) => {
    try {
      const tempData = {
        ...profileData,
        ...stepData,
        currentStep: profileStep,
        lastSaved: new Date().toISOString(),
      };
      await AsyncStorage.setItem(TEMP_PROFILE_KEY, JSON.stringify(tempData));
      console.log(`ÌîÑÎ°úÌïÑ ÏûÑÏãú Ï†ÄÏû• ÏôÑÎ£å - Îã®Í≥Ñ: ${profileStep + 1}`);
    } catch (error) {
      console.error("ÏûÑÏãú Ï†ÄÏû• Ïò§Î•ò:", error);
    }
  };

  // üÜï ÏûÑÏãú Ï†ÄÏû• Îç∞Ïù¥ÌÑ∞ Î°úÎìú
  const loadTempProfile = async () => {
    try {
      const tempData = await AsyncStorage.getItem(TEMP_PROFILE_KEY);
      if (tempData) {
        const parsed = JSON.parse(tempData);
        // 24ÏãúÍ∞Ñ Ïù¥ÎÇ¥ Îç∞Ïù¥ÌÑ∞Îßå Î≥µÏõê
        const lastSaved = new Date(parsed.lastSaved);
        const now = new Date();
        const diffHours = (now - lastSaved) / (1000 * 60 * 60);

        if (diffHours < 24) {
          setProfileData(parsed);
          setProfileStep(parsed.currentStep || 0);
          return true;
        } else {
          // Ïò§ÎûòÎêú ÏûÑÏãú Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
          await AsyncStorage.removeItem(TEMP_PROFILE_KEY);
        }
      }
      return false;
    } catch (error) {
      console.error("ÏûÑÏãú Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïò§Î•ò:", error);
      return false;
    }
  };

  // üÜï ÏûÑÏãú Ï†ÄÏû• Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
  const clearTempProfile = async () => {
    try {
      await AsyncStorage.removeItem(TEMP_PROFILE_KEY);
      console.log("ÏûÑÏãú ÌîÑÎ°úÌïÑ Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú ÏôÑÎ£å");
    } catch (error) {
      console.error("ÏûÑÏãú Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú Ïò§Î•ò:", error);
    }
  };

  // üÜï Í∞úÏÑ†Îêú Ïò§Î•ò Ï≤òÎ¶¨ Ìï®Ïàò
  const handleError = (error, context = "ÏûëÏóÖ") => {
    console.error(`${context} Ïò§Î•ò:`, error);

    let userMessage = "Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.";

    if (
      error.message?.includes("network") ||
      error.message?.includes("fetch")
    ) {
      userMessage = "Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.";
    } else if (error.message?.includes("storage")) {
      userMessage = "Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.";
    } else if (error.message?.includes("API")) {
      userMessage = "AI ÏÑúÎπÑÏä§Ïóê ÏùºÏãúÏ†ÅÏù∏ Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.";
    }

    setError({ message: userMessage, context, canRetry: true });
  };

  // üÜï Ïû¨ÏãúÎèÑ Ìï®Ïàò
  const handleRetry = async () => {
    setIsRetrying(true);
    setError(null);

    try {
      if (error?.context === "AI Î∂ÑÏÑù") {
        await handleAnalysisRequest();
      } else if (error?.context === "ÌîÑÎ°úÌïÑ Ï†ÄÏû•") {
        await completeProfileSetup(profileData);
      }
    } catch (retryError) {
      handleError(retryError, error?.context);
    } finally {
      setIsRetrying(false);
    }
  };

  // ÌîÑÎ°úÌïÑ ÏàòÏ†ï Ìï®Ïàò
  const handleProfileEdit = async (field, newValue) => {
    if (!userContext) return;

    try {
      // üÜï ÎÇòÏù¥ ÌïÑÎìú Ïà´Ïûê Î≥ÄÌôò
      let processedValue = newValue.trim();
      if (field === "age") {
        const ageNum = parseInt(processedValue);
        if (isNaN(ageNum) || ageNum <= 0 || ageNum >= 150) {
          Alert.alert("Ïò§Î•ò", "Ïò¨Î∞îÎ•∏ ÎÇòÏù¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî. (1-149)");
          return;
        }
        processedValue = ageNum;
      }

      const updatedContext = {
        ...userContext,
        [field]: processedValue,
        lastActiveDate: new Date().toISOString(),
      };

      await saveUserContext(updatedContext);
      setUserContext(updatedContext);
      setEditingField(null);
      setEditValue("");
      console.log("ÌîÑÎ°úÌïÑ ÏàòÏ†ï ÏôÑÎ£å:", field, processedValue);
    } catch (error) {
      handleError(error, "ÌîÑÎ°úÌïÑ ÏàòÏ†ï");
    }
  };

  // ÌîÑÎ°úÌïÑ ÌôîÎ©¥ Î†åÎçîÎßÅ (ÍµêÏú° Ìï≠Î™© Ï†úÍ±∞)
  const renderProfileScreen = () => {
    if (!userContext) return null;

    const profileFields = [
      {
        key: "name",
        label: "Ïù¥Î¶Ñ/ÎãâÎÑ§ÏûÑ",
        icon: "person",
        value: userContext.name,
      },
      { key: "age", label: "ÎÇòÏù¥", icon: "calendar", value: userContext.age },
      {
        key: "gender",
        label: "ÏÑ±Î≥Ñ",
        icon: "male-female",
        value: userContext.gender || "ÎØ∏ÏûÖÎ†•",
      },
      {
        key: "occupation",
        label: "ÏßÅÏóÖ/ÏÉÅÌô©",
        icon: "briefcase",
        value: userContext.occupation,
      },
      {
        key: "personality",
        label: "ÏÑ±Í≤©/MBTI",
        icon: "happy",
        value: userContext.personality || "ÎØ∏ÏûÖÎ†•",
      },
      {
        key: "targetGoal",
        label: "Î™©Ìëú",
        icon: "flag",
        value: userContext.targetGoal || "ÎØ∏ÏûÖÎ†•",
      },
      {
        key: "preferredStyle",
        label: "ÌïôÏäµ Ïä§ÌÉÄÏùº",
        icon: "library",
        value:
          userContext.preferredStyle === "intensive"
            ? "Î™∞ÏûÖÌòï"
            : userContext.preferredStyle === "distributed"
            ? "Î∂ÑÏÇ∞Ìòï"
            : "Í∑†ÌòïÌòï",
      },
    ];

    return (
      <KeyboardAvoidingView
        style={{ flex: 1, backgroundColor: "#fafbfc" }}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        keyboardVerticalOffset={Platform.OS === "ios" ? 100 : 0}
      >
        {/* Ìó§Îçî */}
        <View
          style={{
            backgroundColor: "#ffffff",
            paddingHorizontal: 16,
            paddingVertical: 12,
            borderBottomWidth: 1,
            borderBottomColor: "#eee",
            flexDirection: "row",
            alignItems: "center",
          }}
        >
          <TouchableOpacity
            onPress={() => {
              setShowProfileScreen(false);
              setEditingField(null);
              setEditValue("");
            }}
            style={{ marginRight: 12 }}
          >
            <Ionicons name="arrow-back" size={24} color="#333" />
          </TouchableOpacity>
          <Text
            style={{
              fontSize: 18,
              fontWeight: "600",
              color: "#333",
              flex: 1,
            }}
          >
            ÎÇ¥ ÌîÑÎ°úÌïÑ
          </Text>
          <Text style={{ fontSize: 12, color: "#999" }}>
            {userContext.totalSessions || 0}Ìöå ÏÇ¨Ïö©
          </Text>
        </View>

        <ScrollView
          style={{ flex: 1 }}
          contentContainerStyle={{
            padding: 20,
            paddingBottom: keyboardHeight > 0 ? keyboardHeight + 40 : 40,
          }}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >
          {/* ÌîÑÎ°úÌïÑ Ïπ¥Îìú */}
          <View
            style={{
              backgroundColor: "#ffffff",
              padding: 24,
              borderRadius: 20,
              marginBottom: 20,
              shadowColor: "#000",
              shadowOffset: { width: 0, height: 2 },
              shadowOpacity: 0.08,
              shadowRadius: 12,
              elevation: 4,
              borderWidth: 1,
              borderColor: "#f0f0f0",
            }}
          >
            <View
              style={{
                flexDirection: "row",
                alignItems: "center",
                marginBottom: 20,
              }}
            >
              <View
                style={{
                  width: 60,
                  height: 60,
                  borderRadius: 30,
                  backgroundColor: "#50cebb",
                  justifyContent: "center",
                  alignItems: "center",
                  marginRight: 16,
                }}
              >
                <Ionicons name="person" size={28} color="#fff" />
              </View>
              <View style={{ flex: 1 }}>
                <Text
                  style={{ fontSize: 20, fontWeight: "700", color: "#1a1a1a" }}
                >
                  {userContext.name}ÎãòÏùò ÌîÑÎ°úÌïÑ
                </Text>
                <Text style={{ fontSize: 12, color: "#888", marginTop: 4 }}>
                  Í∞ÄÏûÖÏùº:{" "}
                  {format(new Date(userContext.createdAt), "yyyyÎÖÑ MÏõî dÏùº")}
                </Text>
              </View>
            </View>

            {profileFields.map((field, index) => (
              <View
                key={field.key}
                style={{
                  flexDirection: "row",
                  alignItems: "center",
                  paddingVertical: 16,
                  borderBottomWidth: index === profileFields.length - 1 ? 0 : 1,
                  borderBottomColor: "#f5f5f5",
                }}
              >
                <View
                  style={{
                    width: 40,
                    height: 40,
                    borderRadius: 20,
                    backgroundColor: "#f8f9fa",
                    justifyContent: "center",
                    alignItems: "center",
                    marginRight: 16,
                  }}
                >
                  <Ionicons name={field.icon} size={20} color="#50cebb" />
                </View>

                <View style={{ flex: 1 }}>
                  <Text
                    style={{ fontSize: 14, color: "#666", marginBottom: 4 }}
                  >
                    {field.label}
                  </Text>
                  {editingField === field.key ? (
                    <View
                      style={{ flexDirection: "row", alignItems: "center" }}
                    >
                      {field.key === "gender" ? (
                        // ÏÑ±Î≥ÑÏùÄ Î≤ÑÌäºÏúºÎ°ú ÏÑ†ÌÉù
                        <View style={{ flex: 1, flexDirection: "row", gap: 8 }}>
                          {["ÎÇ®ÏÑ±", "Ïó¨ÏÑ±"].map((option) => (
                            <TouchableOpacity
                              key={option}
                              style={{
                                flex: 1,
                                backgroundColor:
                                  editValue === option ? "#50cebb" : "#f8f9fa",
                                borderRadius: 8,
                                paddingVertical: 10,
                                alignItems: "center",
                                borderWidth: 1,
                                borderColor:
                                  editValue === option ? "#50cebb" : "#e0e0e0",
                              }}
                              onPress={() => setEditValue(option)}
                            >
                              <Text
                                style={{
                                  color: editValue === option ? "#fff" : "#333",
                                  fontSize: 14,
                                  fontWeight: "600",
                                }}
                              >
                                {option}
                              </Text>
                            </TouchableOpacity>
                          ))}
                        </View>
                      ) : field.key === "preferredStyle" ? (
                        // ÌïôÏäµ Ïä§ÌÉÄÏùºÏùÄ Î≤ÑÌäºÏúºÎ°ú ÏÑ†ÌÉù
                        <View style={{ flex: 1, gap: 4 }}>
                          {[
                            { label: "Î™∞ÏûÖÌòï", value: "intensive" },
                            { label: "Î∂ÑÏÇ∞Ìòï", value: "distributed" },
                            { label: "Í∑†ÌòïÌòï", value: "balanced" },
                          ].map((option) => (
                            <TouchableOpacity
                              key={option.value}
                              style={{
                                backgroundColor:
                                  editValue === option.value
                                    ? "#50cebb"
                                    : "#f8f9fa",
                                borderRadius: 8,
                                paddingVertical: 8,
                                paddingHorizontal: 12,
                                borderWidth: 1,
                                borderColor:
                                  editValue === option.value
                                    ? "#50cebb"
                                    : "#e0e0e0",
                              }}
                              onPress={() => setEditValue(option.value)}
                            >
                              <Text
                                style={{
                                  color:
                                    editValue === option.value
                                      ? "#fff"
                                      : "#333",
                                  fontSize: 14,
                                  fontWeight: "600",
                                  textAlign: "center",
                                }}
                              >
                                {option.label}
                              </Text>
                            </TouchableOpacity>
                          ))}
                        </View>
                      ) : (
                        // ÏùºÎ∞ò ÌÖçÏä§Ìä∏ ÏûÖÎ†•
                        <TextInput
                          style={{
                            flex: 1,
                            borderWidth: 1,
                            borderColor: "#50cebb",
                            borderRadius: 8,
                            paddingHorizontal: 12,
                            paddingVertical: 8,
                            fontSize: 16,
                            backgroundColor: "#fff",
                            minHeight: 40,
                          }}
                          value={editValue}
                          onChangeText={setEditValue}
                          autoFocus
                          placeholder={field.label}
                          keyboardType={
                            field.key === "age" ? "numeric" : "default"
                          }
                        />
                      )}
                      <TouchableOpacity
                        style={{
                          marginLeft: 8,
                          backgroundColor: "#50cebb",
                          borderRadius: 16,
                          paddingHorizontal: 12,
                          paddingVertical: 6,
                        }}
                        onPress={() => handleProfileEdit(field.key, editValue)}
                      >
                        <Text
                          style={{
                            color: "#fff",
                            fontSize: 12,
                            fontWeight: "600",
                          }}
                        >
                          Ï†ÄÏû•
                        </Text>
                      </TouchableOpacity>
                      <TouchableOpacity
                        style={{ marginLeft: 4, padding: 6 }}
                        onPress={() => {
                          setEditingField(null);
                          setEditValue("");
                        }}
                      >
                        <Ionicons name="close" size={16} color="#999" />
                      </TouchableOpacity>
                    </View>
                  ) : (
                    <TouchableOpacity
                      onPress={() => {
                        setEditingField(field.key);
                        setEditValue(
                          field.value === "ÎØ∏ÏûÖÎ†•" ? "" : field.value.toString()
                        );
                      }}
                      style={{ flexDirection: "row", alignItems: "center" }}
                    >
                      <Text
                        style={{
                          fontSize: 16,
                          color: field.value === "ÎØ∏ÏûÖÎ†•" ? "#999" : "#333",
                          flex: 1,
                        }}
                      >
                        {field.value}
                      </Text>
                      <Ionicons name="create-outline" size={16} color="#999" />
                    </TouchableOpacity>
                  )}
                </View>
              </View>
            ))}
          </View>

          {/* ÏÑ§Ï†ï ÏôÑÎ£å Ï†ïÎ≥¥ */}
          <View
            style={{
              backgroundColor: "#ffffff",
              padding: 20,
              borderRadius: 16,
              shadowColor: "#000",
              shadowOffset: { width: 0, height: 1 },
              shadowOpacity: 0.05,
              shadowRadius: 8,
              elevation: 2,
              borderWidth: 1,
              borderColor: "#f0f0f0",
            }}
          >
            <View
              style={{
                flexDirection: "row",
                alignItems: "center",
                marginBottom: 16,
              }}
            >
              <Ionicons name="checkmark-circle" size={20} color="#50cebb" />
              <Text
                style={{
                  fontSize: 16,
                  fontWeight: "600",
                  color: "#1a1a1a",
                  marginLeft: 8,
                }}
              >
                ÏÑ§Ï†ï ÏôÑÎ£å
              </Text>
            </View>
            <Text
              style={{
                fontSize: 14,
                color: "#666",
                lineHeight: 20,
              }}
            >
              ÌîÑÎ°úÌïÑ ÏÑ§Ï†ïÏù¥ ÏôÑÎ£åÎêòÏñ¥{"\n"}
              Í∞úÏù∏ÌôîÎêú AI ÌîºÎìúÎ∞±ÏùÑ Î∞õÏúºÏã§ Ïàò ÏûàÏäµÎãàÎã§.
            </Text>
          </View>

          <View style={{ height: 50 }} />
        </ScrollView>
      </KeyboardAvoidingView>
    );
  };

  const toggleInputMode = () => {
    const toValue = isInputMode ? 0 : 1;
    setIsInputMode(!isInputMode);

    Animated.timing(slideAnim, {
      toValue,
      duration: 300,
      useNativeDriver: true,
    }).start();
  };

  const returnToResultMode = () => {
    setIsInputMode(false);
    Animated.timing(slideAnim, {
      toValue: 0,
      duration: 300,
      useNativeDriver: true,
    }).start();
  };

  const renderStartScreen = () => (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
        paddingHorizontal: 32,
      }}
    >
      <View
        style={{
          alignItems: "center",
          marginBottom: 40,
        }}
      >
        <Ionicons
          name="sparkles"
          size={64}
          color="#50cebb"
          style={{ marginBottom: 20 }}
        />
        <Text
          style={{
            fontSize: 24,
            fontWeight: "bold",
            color: "#333",
            marginBottom: 12,
            textAlign: "center",
          }}
        >
          AI ÎßûÏ∂§ ÌîºÎìúÎ∞±
        </Text>
        <Text
          style={{
            fontSize: 16,
            color: "#666",
            textAlign: "center",
            lineHeight: 24,
          }}
        >
          ÎãπÏã†ÎßåÏùò AI ÌïôÏäµ ÏΩîÏπòÍ∞Ä{"\n"}
          Í∞úÏù∏ÌôîÎêú Ï°∞Ïñ∏ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§
        </Text>
      </View>

      <TouchableOpacity
        style={{
          backgroundColor: "#50cebb",
          paddingHorizontal: 32,
          paddingVertical: 16,
          borderRadius: 25,
          flexDirection: "row",
          alignItems: "center",
          shadowColor: "#000",
          shadowOffset: { width: 0, height: 2 },
          shadowOpacity: 0.1,
          shadowRadius: 4,
          elevation: 3,
        }}
        onPress={handleStartAI}
      >
        <Ionicons
          name="play"
          size={20}
          color="#fff"
          style={{ marginRight: 8 }}
        />
        <Text
          style={{
            color: "#fff",
            fontSize: 18,
            fontWeight: "600",
          }}
        >
          AI ÏΩîÏπò ÏãúÏûëÌïòÍ∏∞
        </Text>
      </TouchableOpacity>

      <Text
        style={{
          fontSize: 12,
          color: "#999",
          textAlign: "center",
          marginTop: 20,
          lineHeight: 18,
        }}
      >
        üí° Î™á Í∞ÄÏßÄ Í∞ÑÎã®Ìïú ÏÑ§Ï†ïÏúºÎ°ú{"\n"}
        ÎãπÏã†ÎßåÏùò AI ÏΩîÏπòÎ•º ÎßåÎì§Ïñ¥Î≥¥ÏÑ∏Ïöî
      </Text>
    </View>
  );

  // üÜï Í∞úÏÑ†Îêú ÌîÑÎ°úÌïÑ ÏÑ§Ï†ï ÌôîÎ©¥ (ÏûÑÏãú Ï†ÄÏû• Ìè¨Ìï®)
  const renderProfileSetupScreen = () => {
    const currentQuestion = profileQuestions[profileStep];

    return (
      <KeyboardAvoidingView
        style={{ flex: 1, backgroundColor: "#fafbfc" }}
        behavior={Platform.OS === "ios" ? "padding" : "height"}
        keyboardVerticalOffset={Platform.OS === "ios" ? 100 : 0}
      >
        <ScrollView
          style={{ flex: 1 }}
          contentContainerStyle={{
            flexGrow: 1,
            padding: 20,
            paddingBottom: keyboardHeight > 0 ? keyboardHeight + 40 : 40,
          }}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >
          {/* ÏßÑÌñâ ÏÉÅÌô© */}
          <View style={{ marginBottom: 30 }}>
            <View
              style={{
                flexDirection: "row",
                justifyContent: "space-between",
                alignItems: "center",
                marginBottom: 8,
              }}
            >
              <Text style={{ fontSize: 14, color: "#888" }}>
                ÏßÑÌñâ ÏÉÅÌô©: {profileStep + 1} / {profileQuestions.length}
              </Text>
              <Text style={{ fontSize: 14, color: "#888" }}>
                {Math.round(
                  ((profileStep + 1) / profileQuestions.length) * 100
                )}
                %
              </Text>
            </View>
            <View
              style={{
                height: 4,
                backgroundColor: "#e0e0e0",
                borderRadius: 2,
              }}
            >
              <View
                style={{
                  height: 4,
                  backgroundColor: "#50cebb",
                  borderRadius: 2,
                  width: `${
                    ((profileStep + 1) / profileQuestions.length) * 100
                  }%`,
                }}
              />
            </View>
          </View>

          {/* ÏßàÎ¨∏ Ïπ¥Îìú */}
          <View
            style={{
              backgroundColor: "#ffffff",
              padding: 24,
              borderRadius: 20,
              marginBottom: 30,
              shadowColor: "#000",
              shadowOffset: { width: 0, height: 2 },
              shadowOpacity: 0.08,
              shadowRadius: 12,
              elevation: 4,
              borderWidth: 1,
              borderColor: "#f0f0f0",
            }}
          >
            <View
              style={{
                flexDirection: "row",
                alignItems: "center",
                marginBottom: 20,
              }}
            >
              <View
                style={{
                  width: 40,
                  height: 40,
                  borderRadius: 20,
                  backgroundColor: "#50cebb",
                  justifyContent: "center",
                  alignItems: "center",
                  marginRight: 12,
                }}
              >
                <Ionicons name="help" size={20} color="#fff" />
              </View>
              <Text
                style={{
                  fontSize: 18,
                  fontWeight: "700",
                  color: "#1a1a1a",
                  flex: 1,
                }}
              >
                ÏßàÎ¨∏ {profileStep + 1}
              </Text>
            </View>

            <Text
              style={{
                fontSize: 16,
                color: "#333",
                lineHeight: 24,
                marginBottom: 20,
              }}
            >
              {currentQuestion.question}
            </Text>

            {/* ÏûÖÎ†• Î∞©ÏãùÏóê Îî∞Î•∏ UI */}
            {currentQuestion.type === "text" ? (
              <TextInput
                style={{
                  borderWidth: 1,
                  borderColor: "#e0e0e0",
                  borderRadius: 12,
                  paddingHorizontal: 16,
                  paddingVertical: 12,
                  fontSize: 16,
                  backgroundColor: "#ffffff",
                  minHeight: 48,
                }}
                value={inputText}
                onChangeText={setInputText}
                placeholder={
                  currentQuestion.placeholder || "ÎãµÎ≥ÄÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî..."
                }
                placeholderTextColor="#999"
                keyboardType={
                  currentQuestion.key === "age" ? "numeric" : "default"
                }
              />
            ) : (
              // Î≤ÑÌäº ÏÑ†ÌÉù
              <View>
                {currentQuestion.options.map((option, index) => {
                  const isObject = typeof option === "object";
                  const label = isObject ? option.label : option;
                  const value = isObject ? option.value : option;

                  return (
                    <TouchableOpacity
                      key={index}
                      style={{
                        backgroundColor:
                          inputText === value ? "#50cebb" : "#f8f9fa",
                        padding: 16,
                        borderRadius: 12,
                        marginBottom: 12,
                        borderWidth: 1,
                        borderColor:
                          inputText === value ? "#50cebb" : "#e0e0e0",
                      }}
                      onPress={() => setInputText(value)}
                    >
                      <Text
                        style={{
                          color: inputText === value ? "#fff" : "#333",
                          fontSize: 16,
                          fontWeight: inputText === value ? "600" : "400",
                          textAlign: "center",
                        }}
                      >
                        {label}
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </View>
            )}
          </View>

          {/* Î≤ÑÌäºÎì§ */}
          <View
            style={{
              flexDirection: "row",
              justifyContent: "space-between",
              gap: 12,
            }}
          >
            {profileStep > 0 && (
              <TouchableOpacity
                style={{
                  flex: 1,
                  backgroundColor: "#f8f9fa",
                  paddingVertical: 16,
                  borderRadius: 12,
                  alignItems: "center",
                  borderWidth: 1,
                  borderColor: "#e0e0e0",
                }}
                onPress={() => {
                  setProfileStep(profileStep - 1);
                  setInputText("");
                }}
              >
                <Text
                  style={{ color: "#666", fontSize: 16, fontWeight: "600" }}
                >
                  Ïù¥Ï†Ñ
                </Text>
              </TouchableOpacity>
            )}

            <TouchableOpacity
              style={{
                flex: profileStep > 0 ? 1 : 1,
                backgroundColor: canProceedToNext() ? "#50cebb" : "#e0e0e0",
                paddingVertical: 16,
                borderRadius: 12,
                alignItems: "center",
              }}
              onPress={handleNextStep}
              disabled={!canProceedToNext()}
            >
              <Text
                style={{
                  color: canProceedToNext() ? "#fff" : "#999",
                  fontSize: 16,
                  fontWeight: "600",
                }}
              >
                {profileStep === profileQuestions.length - 1 ? "ÏôÑÎ£å" : "Îã§Ïùå"}
              </Text>
            </TouchableOpacity>
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    );
  };

  // üÜï Îã§Ïùå Îã®Í≥Ñ ÏßÑÌñâ Í∞ÄÎä• Ïó¨Î∂Ä ÌôïÏù∏
  const canProceedToNext = () => {
    const currentQuestion = profileQuestions[profileStep];
    const answer = inputText.trim();

    // ÌïÑÏàò ÌïÑÎìú Ï≤¥ÌÅ¨
    if (currentQuestion.validation) {
      return currentQuestion.validation(answer);
    }

    // ÏÑ†ÌÉùÏÇ¨Ìï≠ÏùÄ Îπà Í∞íÎèÑ ÌóàÏö©
    return true;
  };

  useEffect(() => {
    const keyboardDidShowListener = Keyboard.addListener(
      "keyboardDidShow",
      (e) => setKeyboardHeight(e.endCoordinates.height)
    );
    const keyboardDidHideListener = Keyboard.addListener(
      "keyboardDidHide",
      () => setKeyboardHeight(0)
    );

    // üÜï Ïï± ÏÉÅÌÉú Î≥ÄÍ≤Ω Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
    const appStateSubscription = AppState.addEventListener(
      "change",
      handleAppStateChange
    );

    loadInitialData();

    // üÜï ÏûêÏ†ï ÌÉÄÏù¥Î®∏ ÏÑ§Ï†ï
    setupMidnightTimer();

    return () => {
      keyboardDidHideListener?.remove();
      keyboardDidShowListener?.remove();
      appStateSubscription?.remove();

      // üÜï ÌÉÄÏù¥Î®∏ Ï†ïÎ¶¨
      if (midnightTimerRef.current) {
        clearTimeout(midnightTimerRef.current);
      }
      stopCountdownTimer();
    };
  }, []);

  // üÜï hasAnalyzedToday Î≥ÄÍ≤Ω Ïãú Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Í¥ÄÎ¶¨
  useEffect(() => {
    if (hasAnalyzedToday) {
      startCountdownTimer();
    } else {
      stopCountdownTimer();
      setTimeRemaining("");
    }
  }, [hasAnalyzedToday]);

  const loadInitialData = async () => {
    try {
      const [savedUserContext, yesterdayAnalysis, recentAnalyses] =
        await Promise.all([
          getUserContext(),
          getYesterdayAnalysisResult(),
          getRecentAnalysisResults(7),
        ]);

      // üÜï Ïò§Îäò Î∂ÑÏÑù Ïó¨Î∂Ä Ï≤¥ÌÅ¨
      const todayAnalysis = await hasAnalysisToday();
      setHasAnalyzedToday(todayAnalysis);

      if (savedUserContext) {
        setUserContext(savedUserContext);
        setIsStarted(true);
        setShowAnalysisScreen(true);
        console.log("Í∏∞Ï°¥ ÏÇ¨Ïö©Ïûê Î≥µÍ∑Ä:", savedUserContext.name);
      } else {
        // üÜï ÏûÑÏãú Ï†ÄÏû• Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏
        const hasTemp = await loadTempProfile();
        if (hasTemp) {
          console.log("ÏûÑÏãú Ï†ÄÏû• Îç∞Ïù¥ÌÑ∞ Î≥µÏõêÎê®");
        }
      }

      if (yesterdayAnalysis) {
        setYesterdayResult(yesterdayAnalysis);
      }

      if (recentAnalyses && recentAnalyses.length > 0) {
        const today = format(new Date(), "yyyy-MM-dd");
        const yesterday = format(
          new Date(Date.now() - 24 * 60 * 60 * 1000),
          "yyyy-MM-dd"
        );

        const processedResults = recentAnalyses.map((result) => {
          const resultDate = result.date;
          const isToday = resultDate === today;
          const isYesterday = resultDate === yesterday;

          const resultDateTime = new Date(resultDate).getTime();
          const todayTime = new Date(today).getTime();
          const daysAgo = Math.floor(
            (todayTime - resultDateTime) / (24 * 60 * 60 * 1000)
          );

          return {
            ...result,
            isToday,
            isYesterday,
            daysAgo,
          };
        });

        setRecentResults(processedResults);
        setAnalysisResult(processedResults[0]);
        setSelectedResultIndex(0);
      }

      console.log("Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏôÑÎ£å:", {
        hasUser: !!savedUserContext,
        hasYesterday: !!yesterdayAnalysis,
        recentCount: recentAnalyses?.length || 0,
        hasAnalyzedToday: todayAnalysis,
      });
    } catch (error) {
      handleError(error, "Îç∞Ïù¥ÌÑ∞ Î°úÎìú");
    }
  };

  const handleStartAI = async () => {
    setIsStarted(true);

    // üÜï ÏûÑÏãú Ï†ÄÏû• Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
    const hasTemp = await loadTempProfile();
    if (hasTemp) {
      // ÏûÑÏãú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ Ìï¥Îãπ Îã®Í≥ÑÎ∂ÄÌÑ∞ ÏãúÏûë
      Alert.alert(
        "Ïù¥Ï†Ñ ÏÑ§Ï†ï Î∞úÍ≤¨",
        "Ïù¥Ï†ÑÏóê ÏÑ§Ï†ïÌïòÎçò ÌîÑÎ°úÌïÑ Ï†ïÎ≥¥Í∞Ä ÏûàÏäµÎãàÎã§. Ïù¥Ïñ¥ÏÑú ÏßÑÌñâÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
        [
          {
            text: "ÏÉàÎ°ú ÏãúÏûë",
            onPress: () => {
              clearTempProfile();
              setProfileData({});
              setProfileStep(0);
              setIsCollectingProfile(true);
            },
          },
          {
            text: "Ïù¥Ïñ¥ÏÑú ÏßÑÌñâ",
            onPress: () => {
              setIsCollectingProfile(true);
            },
          },
        ]
      );
    } else {
      setIsCollectingProfile(true);
      setProfileStep(0);
      setInputText("");
    }
  };

  // üÜï Í∞úÏÑ†Îêú Îã§Ïùå Îã®Í≥Ñ Ï≤òÎ¶¨ (ÏûÑÏãú Ï†ÄÏû• Ìè¨Ìï®)
  const handleNextStep = async () => {
    const currentQuestion = profileQuestions[profileStep];
    const answer = inputText.trim();

    // üÜï Í∞ïÌôîÎêú Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (currentQuestion.validation && !currentQuestion.validation(answer)) {
      Alert.alert(
        "ÏûÖÎ†• Ïò§Î•ò",
        currentQuestion.errorMsg || "Ïò¨Î∞îÎ•∏ Í∞íÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî."
      );
      return;
    }

    // ÌîÑÎ°úÌïÑ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
    const newProfileData = {
      ...profileData,
      [currentQuestion.key]: answer,
    };
    setProfileData(newProfileData);

    // üÜï ÏûÑÏãú Ï†ÄÏû•
    await saveTempProfile({ [currentQuestion.key]: answer });

    const nextStep = profileStep + 1;

    if (nextStep < profileQuestions.length) {
      // Îã§Ïùå ÏßàÎ¨∏ÏúºÎ°ú
      setProfileStep(nextStep);
      setInputText("");
    } else {
      // Î™®Îì† ÏßàÎ¨∏ ÏôÑÎ£å
      await completeProfileSetup(newProfileData);
    }
  };

  // üÜï Í∞úÏÑ†Îêú ÌîÑÎ°úÌïÑ ÏÑ§Ï†ï ÏôÑÎ£å (ÎÇòÏù¥ Ïà´Ïûê Î≥ÄÌôò Ìè¨Ìï®)
  const completeProfileSetup = async (finalProfileData) => {
    try {
      let normalizedStyle = "balanced";
      if (finalProfileData.studyStyle) {
        normalizedStyle = finalProfileData.studyStyle;
      }

      // üÜï ÎÇòÏù¥Î•º Ïà´ÏûêÎ°ú Î≥ÄÌôò
      const age = parseInt(finalProfileData.age);
      if (isNaN(age) || age <= 0) {
        throw new Error("Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏùÄ ÎÇòÏù¥ Ï†ïÎ≥¥ÏûÖÎãàÎã§.");
      }

      const newUserContext = {
        name: finalProfileData.name,
        age: age, // üÜï Ïà´ÏûêÌòïÏúºÎ°ú Ï†ÄÏû•
        gender:
          finalProfileData.gender === "ÏÑ†ÌÉùÏïàÌï®" ? "" : finalProfileData.gender,
        occupation: finalProfileData.occupation,
        personality: finalProfileData.personality || "",
        targetGoal: finalProfileData.goal || "",
        preferredStyle: normalizedStyle,
        createdAt: new Date().toISOString(),
        totalSessions: 0,
        lastActiveDate: new Date().toISOString(),
      };

      await saveUserContext(newUserContext);
      setUserContext(newUserContext);

      // üÜï ÏûÑÏãú Ï†ÄÏû• Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
      await clearTempProfile();

      // 1Ï¥à ÌõÑ Î∂ÑÏÑù ÌôîÎ©¥ÏúºÎ°ú Ï†ÑÌôò
      setTimeout(() => {
        setIsCollectingProfile(false);
        setShowAnalysisScreen(true);
        setInputText("");
        setProfileStep(0);
        setProfileData({});
      }, 1000);

      console.log("ÌîÑÎ°úÌïÑ ÏÑ§Ï†ï ÏôÑÎ£å:", newUserContext.name);
    } catch (error) {
      handleError(error, "ÌîÑÎ°úÌïÑ Ï†ÄÏû•");
    }
  };

  // üÜï Í∞úÏÑ†Îêú AI Î∂ÑÏÑù ÏöîÏ≤≠ (Ïò§Î•ò Ï≤òÎ¶¨ Í∞ïÌôî)
  const handleAnalysisRequest = async () => {
    if (!analysisInput.trim() || isAnalyzing || hasAnalyzedToday) return;

    setIsAnalyzing(true);
    setError(null);

    try {
      const plannerData = {
        schedules: schedules || {},
        tasks: tasks || {},
        studySessions: studySessions || {},
        goalTargets: goalTargets || [],
        weeklyStats: weeklyStats || {},
        monthlyStats: monthlyStats || {},
      };

      const result = await testDeepSeekAPI({
        reportType: "daily",
        plannerData: plannerData,
        userInput: analysisInput.trim(),
        userContext: userContext,
        chatHistory: [],
      });

      if (result.success) {
        const newAnalysisResult = {
          ...result.data,
          userInput: analysisInput.trim(),
          date: format(new Date(), "yyyy-MM-dd"),
          timestamp: new Date().toISOString(),
        };

        setAnalysisResult(newAnalysisResult);

        const today = format(new Date(), "yyyy-MM-dd");
        await saveAnalysisResult(today, newAnalysisResult);

        // üÜï Î∂ÑÏÑù ÏôÑÎ£å ÌõÑ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        setHasAnalyzedToday(true);
        setAnalysisInput("");

        const updatedRecentResults = await getRecentAnalysisResults(7);
        const yesterday = format(
          new Date(Date.now() - 24 * 60 * 60 * 1000),
          "yyyy-MM-dd"
        );

        const processedResults = updatedRecentResults.map((result) => {
          const resultDate = result.date;
          const isToday = resultDate === today;
          const isYesterday = resultDate === yesterday;

          const resultDateTime = new Date(resultDate).getTime();
          const todayTime = new Date(today).getTime();
          const daysAgo = Math.floor(
            (todayTime - resultDateTime) / (24 * 60 * 60 * 1000)
          );

          return {
            ...result,
            isToday,
            isYesterday,
            daysAgo,
          };
        });

        setRecentResults(processedResults);
        setSelectedResultIndex(0);
        returnToResultMode();

        console.log(
          "‚úÖ Î∂ÑÏÑù ÏôÑÎ£å Î∞è Ï†ÄÏû•Îê®:",
          today,
          "- Îã§Ïùå ÏûêÏ†ïÍπåÏßÄ ÎπÑÌôúÏÑ±Ìôî"
        );
      } else {
        throw new Error(result.error || "AI Î∂ÑÏÑùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.");
      }
    } catch (error) {
      handleError(error, "AI Î∂ÑÏÑù");
      setAnalysisResult({
        analysis: "Î∂ÑÏÑù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
        insights: "Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.",
        userInput: analysisInput.trim(),
        date: format(new Date(), "yyyy-MM-dd"),
        timestamp: new Date().toISOString(),
        isError: true,
      });
      returnToResultMode();
    } finally {
      setIsAnalyzing(false);
    }
  };

  // ÎÇ†ÏßúÎ≥Ñ Î∂ÑÏÑù Í≤∞Í≥º ÏÑ†ÌÉù Ìï®Ïàò
  const selectAnalysisResult = (index) => {
    if (recentResults[index]) {
      setSelectedResultIndex(index);
      setAnalysisResult(recentResults[index]);
    }
  };

  // ÎÇ†Ïßú Ìè¨Îß∑ÌåÖ Ìï®Ïàò
  const formatAnalysisDate = (dateStr, isToday, isYesterday, daysAgo) => {
    if (isToday) return "Ïò§Îäò";
    if (isYesterday) return "Ïñ¥Ï†ú";
    if (daysAgo === 2) return "Í∑∏Ï†ú";
    if (daysAgo <= 7) return `${daysAgo}Ïùº Ï†Ñ`;
    return format(new Date(dateStr), "M/d");
  };

  // üÜï Ïò§Î•ò ÌëúÏãú Ïª¥Ìè¨ÎÑåÌä∏
  const renderError = () => {
    if (!error) return null;

    return (
      <View
        style={{
          backgroundColor: "#fff3cd",
          padding: 16,
          margin: 20,
          borderRadius: 12,
          borderLeftWidth: 4,
          borderLeftColor: "#ffc107",
        }}
      >
        <View
          style={{
            flexDirection: "row",
            alignItems: "center",
            marginBottom: 12,
          }}
        >
          <Ionicons name="warning" size={20} color="#856404" />
          <Text
            style={{
              fontSize: 16,
              fontWeight: "600",
              color: "#856404",
              marginLeft: 8,
            }}
          >
            Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§
          </Text>
        </View>
        <Text
          style={{
            fontSize: 14,
            color: "#856404",
            lineHeight: 20,
            marginBottom: 16,
          }}
        >
          {error.message}
        </Text>
        {error.canRetry && (
          <TouchableOpacity
            style={{
              backgroundColor: "#ffc107",
              paddingHorizontal: 16,
              paddingVertical: 10,
              borderRadius: 8,
              alignSelf: "flex-start",
            }}
            onPress={handleRetry}
            disabled={isRetrying}
          >
            <Text
              style={{
                color: "#ffffff",
                fontSize: 14,
                fontWeight: "600",
              }}
            >
              {isRetrying ? "Ïû¨ÏãúÎèÑ Ï§ë..." : "Îã§Ïãú ÏãúÎèÑ"}
            </Text>
          </TouchableOpacity>
        )}
      </View>
    );
  };

  // Î∂ÑÏÑù Í≤∞Í≥º ÌôîÎ©¥ Î†åÎçîÎßÅ
  const renderAnalysisResultView = () => (
    <View style={{ flex: 1, backgroundColor: "#fafbfc" }}>
      {/* Ïò§Î•ò ÌëúÏãú */}
      {error && renderError()}

      {/* ÎÇ†ÏßúÎ≥Ñ ÌÉ≠ */}
      {recentResults.length > 0 && (
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          style={{
            backgroundColor: "#ffffff",
            borderBottomWidth: 1,
            borderBottomColor: "#f0f0f0",
            maxHeight: 60,
          }}
          contentContainerStyle={{
            paddingHorizontal: 16,
            paddingVertical: 10,
            alignItems: "center",
          }}
        >
          {recentResults.map((result, index) => {
            const displayText = formatAnalysisDate(
              result.date,
              result.isToday,
              result.isYesterday,
              result.daysAgo
            );

            return (
              <TouchableOpacity
                key={`${result.date}-${index}`}
                style={{
                  paddingHorizontal: 16,
                  paddingVertical: 8,
                  borderRadius: 20,
                  backgroundColor:
                    selectedResultIndex === index ? "#50cebb" : "#f8f9fa",
                  marginRight: 8,
                  borderWidth: selectedResultIndex === index ? 0 : 1,
                  borderColor: "#e0e0e0",
                  minWidth: 60,
                  height: 40,
                  alignItems: "center",
                  justifyContent: "center",
                }}
                onPress={() => selectAnalysisResult(index)}
              >
                <Text
                  style={{
                    color: selectedResultIndex === index ? "#ffffff" : "#666",
                    fontSize: 14,
                    fontWeight: selectedResultIndex === index ? "600" : "500",
                    textAlign: "center",
                  }}
                >
                  {displayText}
                </Text>
              </TouchableOpacity>
            );
          })}
        </ScrollView>
      )}

      {/* Î∂ÑÏÑù Í≤∞Í≥º ÎÇ¥Ïö© */}
      <ScrollView
        style={{ flex: 1 }}
        contentContainerStyle={{
          padding: 20,
          paddingBottom: 100,
        }}
        showsVerticalScrollIndicator={false}
      >
        <View
          style={{
            backgroundColor: "#ffffff",
            padding: 24,
            borderRadius: 20,
            marginBottom: 20,
            shadowColor: "#000",
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 0.08,
            shadowRadius: 12,
            elevation: 4,
            borderWidth: 1,
            borderColor: "#f0f0f0",
          }}
        >
          <View
            style={{
              flexDirection: "row",
              alignItems: "center",
              marginBottom: 16,
            }}
          >
            <View
              style={{
                width: 40,
                height: 40,
                borderRadius: 20,
                backgroundColor: "#50cebb",
                justifyContent: "center",
                alignItems: "center",
                marginRight: 12,
              }}
            >
              <Ionicons name="analytics" size={20} color="#fff" />
            </View>
            <View style={{ flex: 1 }}>
              <Text
                style={{ fontSize: 18, fontWeight: "700", color: "#1a1a1a" }}
              >
                AI Î∂ÑÏÑù Í≤∞Í≥º
              </Text>
              {analysisResult.date && (
                <Text style={{ fontSize: 12, color: "#888", marginTop: 2 }}>
                  {format(new Date(analysisResult.date), "yyyyÎÖÑ MÏõî dÏùº")}
                </Text>
              )}
            </View>
          </View>

          {/* ÏÇ¨Ïö©Ïûê ÏßàÎ¨∏ ÌëúÏãú */}
          {analysisResult.userInput && (
            <View
              style={{
                backgroundColor: "#f8f9fa",
                padding: 16,
                borderRadius: 12,
                marginBottom: 20,
                borderLeftWidth: 4,
                borderLeftColor: "#50cebb",
              }}
            >
              <Text
                style={{
                  fontSize: 14,
                  color: "#555",
                  fontWeight: "600",
                  marginBottom: 4,
                }}
              >
                üí¨ ÏßàÎ¨∏
              </Text>
              <Text
                style={{
                  fontSize: 15,
                  color: "#333",
                  lineHeight: 22,
                }}
              >
                "{analysisResult.userInput}"
              </Text>
            </View>
          )}

          <Text
            style={{
              fontSize: 15,
              color: "#444",
              lineHeight: 24,
              marginBottom: 20,
            }}
          >
            {analysisResult.analysis || analysisResult.insights}
          </Text>

          {analysisResult.recommendations && (
            <View style={{ marginBottom: 16 }}>
              <Text
                style={{
                  fontSize: 16,
                  fontWeight: "600",
                  color: "#1a1a1a",
                  marginBottom: 12,
                }}
              >
                üìã Ï∂îÏ≤ú ÏùºÏ†ï
              </Text>
              {analysisResult.recommendations.slice(0, 3).map((rec, index) => (
                <View
                  key={index}
                  style={{
                    backgroundColor: "#f8f9fa",
                    padding: 12,
                    borderRadius: 10,
                    marginBottom: 8,
                    borderLeftWidth: 3,
                    borderLeftColor: "#50cebb",
                  }}
                >
                  <Text
                    style={{
                      fontSize: 14,
                      color: "#333",
                      fontWeight: "500",
                    }}
                  >
                    {rec.task}
                  </Text>
                  <Text style={{ fontSize: 12, color: "#666", marginTop: 2 }}>
                    {rec.time}
                  </Text>
                </View>
              ))}
            </View>
          )}

          {analysisResult.focus_areas && (
            <View
              style={{
                backgroundColor: "#fff3cd",
                padding: 12,
                borderRadius: 10,
                borderLeftWidth: 3,
                borderLeftColor: "#ffc107",
                marginBottom: 16,
              }}
            >
              <Text
                style={{ fontSize: 14, color: "#856404", fontWeight: "600" }}
              >
                üéØ ÏßëÏ§ë ÏòÅÏó≠: {analysisResult.focus_areas.join(", ")}
              </Text>
            </View>
          )}

          {analysisResult.personal_advice && (
            <View
              style={{
                backgroundColor: "#e3f2fd",
                padding: 16,
                borderRadius: 12,
                borderLeftWidth: 4,
                borderLeftColor: "#2196f3",
              }}
            >
              <Text
                style={{
                  fontSize: 14,
                  color: "#1565c0",
                  fontWeight: "600",
                  marginBottom: 8,
                }}
              >
                üíù {userContext?.name || "ÏÇ¨Ïö©Ïûê"}ÎãòÎßåÏùÑ ÏúÑÌïú ÌäπÎ≥ÑÌïú Ï°∞Ïñ∏
              </Text>
              <Text
                style={{
                  fontSize: 14,
                  color: "#1976d2",
                  lineHeight: 20,
                }}
              >
                {analysisResult.personal_advice}
              </Text>
            </View>
          )}
        </View>
      </ScrollView>
    </View>
  );

  // ÏûÖÎ†• ÌôîÎ©¥ Î†åÎçîÎßÅ
  const renderAnalysisInputView = () => (
    <KeyboardAvoidingView
      style={{ flex: 1, backgroundColor: "#fafbfc" }}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      keyboardVerticalOffset={Platform.OS === "ios" ? 100 : 0}
    >
      <ScrollView
        ref={inputScrollViewRef}
        style={{ flex: 1 }}
        contentContainerStyle={{
          flexGrow: 1,
          justifyContent: "center",
          alignItems: "center",
          paddingHorizontal: 32,
          paddingVertical: 40,
          paddingBottom: keyboardHeight > 0 ? keyboardHeight - 200 : 40,
        }}
        showsVerticalScrollIndicator={false}
        keyboardShouldPersistTaps="handled"
      >
        {/* AI Î∂ÑÏÑù ÏãúÏûë Î≤ÑÌäº - Ï§ëÏïô Î∞∞Ïπò */}
        <View style={{ alignItems: "center", marginBottom: 40 }}>
          <TouchableOpacity
            style={{
              width: 140,
              height: 140,
              borderRadius: 70,
              backgroundColor:
                analysisInput.trim() && !isAnalyzing && !hasAnalyzedToday
                  ? "#50cebb"
                  : "#e0e0e0",
              justifyContent: "center",
              alignItems: "center",
              shadowColor:
                analysisInput.trim() && !isAnalyzing && !hasAnalyzedToday
                  ? "#50cebb"
                  : "#000",
              shadowOffset: { width: 0, height: 8 },
              shadowOpacity:
                analysisInput.trim() && !isAnalyzing && !hasAnalyzedToday
                  ? 0.3
                  : 0.1,
              shadowRadius: 16,
              elevation: 12,
              borderWidth: 3,
              borderColor: "#ffffff",
            }}
            onPress={handleAnalysisRequest}
            disabled={!analysisInput.trim() || isAnalyzing || hasAnalyzedToday}
          >
            {isAnalyzing ? (
              <>
                <Ionicons name="hourglass" size={40} color="#999" />
                <Text
                  style={{
                    color: "#999",
                    fontSize: 13,
                    fontWeight: "600",
                    marginTop: 8,
                  }}
                >
                  Î∂ÑÏÑù Ï§ë...
                </Text>
              </>
            ) : hasAnalyzedToday ? (
              <>
                <Ionicons name="checkmark-circle" size={40} color="#999" />
                <Text
                  style={{
                    color: "#999",
                    fontSize: 13,
                    fontWeight: "600",
                    marginTop: 8,
                    textAlign: "center",
                  }}
                >
                  Ïò§Îäò Î∂ÑÏÑù ÏôÑÎ£å
                </Text>
              </>
            ) : (
              <>
                <Ionicons name="analytics" size={42} color="#fff" />
                <Text
                  style={{
                    color: "#fff",
                    fontSize: 14,
                    fontWeight: "700",
                    marginTop: 8,
                    letterSpacing: 0.5,
                  }}
                >
                  AI Î∂ÑÏÑù ÏãúÏûë
                </Text>
              </>
            )}
          </TouchableOpacity>

          {/* ÏÉÅÌÉú ÏïàÎÇ¥ ÌÖçÏä§Ìä∏ */}
          <Text
            style={{
              fontSize: 13,
              color: "#888",
              textAlign: "center",
              marginTop: 20,
              fontWeight: "500",
            }}
          >
            {hasAnalyzedToday
              ? "üîí Îã§Ïãú Ïù¥Ïö©ÌïòÎ†§Î©¥ ÏûêÏ†ïÍπåÏßÄ Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî"
              : "üí° ÌïòÎ£® 1Ìöå AI Î∂ÑÏÑù Í∞ÄÎä•"}
          </Text>
        </View>

        {/* üÜï Î∂ÑÏÑù ÏôÑÎ£å ÏÉÅÌÉúÏùº ÎïåÎäî ÏôÑÎ£å Ïπ¥Îìú ÌëúÏãú */}
        {hasAnalyzedToday ? (
          <View
            style={{
              width: "100%",
              backgroundColor: "#ffffff",
              padding: 24,
              borderRadius: 20,
              shadowColor: "#000",
              shadowOffset: { width: 0, height: 2 },
              shadowOpacity: 0.08,
              shadowRadius: 12,
              elevation: 4,
              borderWidth: 1,
              borderColor: "#f0f0f0",
            }}
          >
            <View
              style={{
                flexDirection: "row",
                alignItems: "center",
                marginBottom: 16,
              }}
            >
              <View
                style={{
                  width: 40,
                  height: 40,
                  borderRadius: 20,
                  backgroundColor: "#50cebb",
                  justifyContent: "center",
                  alignItems: "center",
                  marginRight: 12,
                }}
              >
                <Ionicons name="checkmark-done" size={20} color="#fff" />
              </View>
              <View style={{ flex: 1 }}>
                <Text
                  style={{
                    fontSize: 16,
                    fontWeight: "700",
                    color: "#1a1a1a",
                  }}
                >
                  Ïò§ÎäòÏùò AI Î∂ÑÏÑù ÏôÑÎ£å!
                </Text>
                <Text
                  style={{
                    fontSize: 12,
                    color: "#888",
                    marginTop: 2,
                  }}
                >
                  {format(new Date(), "yyyyÎÖÑ MÏõî dÏùº")}
                </Text>
              </View>
            </View>

            <Text
              style={{
                fontSize: 14,
                color: "#666",
                lineHeight: 20,
                marginBottom: 16,
              }}
            >
              Ïò§ÎäòÏùò AI Î∂ÑÏÑùÏù¥ ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§.{"\n"}
              ÎÇ¥Ïùº ÏûêÏ†ï Ïù¥ÌõÑÏóê Îã§Ïãú Ïù¥Ïö© Í∞ÄÎä•Ìï¥Ïöî.
            </Text>

            {/* üÜï Ïã§ÏãúÍ∞Ñ Ïπ¥Ïö¥Ìä∏Îã§Ïö¥ Î∞ïÏä§ */}
            <View
              style={{
                backgroundColor: "#f8f9fa",
                padding: 16,
                borderRadius: 12,
                borderLeftWidth: 4,
                borderLeftColor: "#50cebb",
                alignItems: "center",
              }}
            >
              <Text
                style={{
                  fontSize: 12,
                  color: "#666",
                  marginBottom: 4,
                }}
              >
                Îã§Ïùå Ïù¥Ïö©ÍπåÏßÄ
              </Text>
              <Text
                style={{
                  fontSize: 18,
                  fontWeight: "700",
                  color: "#50cebb",
                  letterSpacing: 1,
                }}
              >
                {timeRemaining || "Í≥ÑÏÇ∞ Ï§ë..."}
              </Text>
            </View>
          </View>
        ) : (
          /* Î∂ÑÏÑù Í∞ÄÎä• ÏÉÅÌÉúÏùº ÎïåÎäî ÏûÖÎ†•Ï∞Ω ÌëúÏãú */
          <View style={{ width: "100%" }}>
            <Text
              style={{
                fontSize: 16,
                fontWeight: "600",
                color: "#1a1a1a",
                marginBottom: 16,
                textAlign: "center",
              }}
            >
              Ïò§ÎäòÏùò Í≥†ÎØºÏù¥ÎÇò Í∂ÅÍ∏àÌïú Ï†êÏùÑ ÏïåÎ†§Ï£ºÏÑ∏Ïöî
            </Text>
            <TextInput
              style={{
                borderWidth: 2,
                borderColor: analysisInput.trim() ? "#50cebb" : "#e0e0e0",
                borderRadius: 16,
                padding: 20,
                fontSize: 16,
                backgroundColor: "#ffffff",
                minHeight: 120,
                textAlignVertical: "top",
                shadowColor: "#000",
                shadowOffset: { width: 0, height: 2 },
                shadowOpacity: 0.05,
                shadowRadius: 8,
                elevation: 2,
              }}
              value={analysisInput}
              onChangeText={setAnalysisInput}
              placeholder="Ïòà: ÌÜ†Ïùµ Í≥µÎ∂ÄÍ∞Ä Ïûò ÏïàÎèºÏöî. ÏßëÏ§ëÎ†•ÏùÑ ÎÜíÏù¥Îäî Î∞©Î≤ïÏù¥ ÏûàÏùÑÍπåÏöî?"
              placeholderTextColor="#aaa"
              multiline
              editable={!isAnalyzing}
              onFocus={() => {
                setTimeout(() => {
                  if (inputScrollViewRef.current) {
                    inputScrollViewRef.current.scrollToEnd({ animated: true });
                  }
                }, 100);
              }}
            />
          </View>
        )}
      </ScrollView>
    </KeyboardAvoidingView>
  );

  // AI Î∂ÑÏÑù ÌôîÎ©¥
  const renderAnalysisScreen = () => (
    <View style={{ flex: 1, position: "relative" }}>
      {/* Î©îÏù∏ ÏΩòÌÖêÏ∏† - Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö© */}
      <Animated.View
        style={[
          { flex: 1 },
          {
            transform: [
              {
                translateX: slideAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [0, -400],
                }),
              },
            ],
          },
        ]}
      >
        {analysisResult ? (
          renderAnalysisResultView()
        ) : (
          <View
            style={{
              flex: 1,
              justifyContent: "center",
              alignItems: "center",
              paddingHorizontal: 32,
            }}
          >
            <View style={{ alignItems: "center", marginBottom: 40 }}>
              <Ionicons
                name="analytics-outline"
                size={64}
                color="#50cebb"
                style={{ marginBottom: 20 }}
              />
              <Text
                style={{
                  fontSize: 24,
                  fontWeight: "bold",
                  color: "#333",
                  marginBottom: 12,
                  textAlign: "center",
                }}
              >
                AI Î∂ÑÏÑù Ï§ÄÎπÑ ÏôÑÎ£å
              </Text>
              <Text
                style={{
                  fontSize: 16,
                  color: "#666",
                  textAlign: "center",
                  lineHeight: 24,
                }}
              >
                Ïö∞Ï∏° ÏÉÅÎã® Î≤ÑÌäºÏùÑ ÎàåÎü¨{"\n"}
                AI Î∂ÑÏÑùÏùÑ ÏãúÏûëÌï¥Î≥¥ÏÑ∏Ïöî
              </Text>
            </View>
          </View>
        )}
      </Animated.View>

      {/* ÏûÖÎ†• ÌôîÎ©¥ - Ïò§Î≤ÑÎ†àÏù¥ */}
      <Animated.View
        style={[
          {
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: "#fafbfc",
          },
          {
            transform: [
              {
                translateX: slideAnim.interpolate({
                  inputRange: [0, 1],
                  outputRange: [400, 0],
                }),
              },
            ],
          },
        ]}
      >
        {renderAnalysisInputView()}
      </Animated.View>

      {/* ÌîåÎ°úÌåÖ Ïï°ÏÖò Î≤ÑÌäº - Ïö∞Ï∏° ÏÉÅÎã® */}
      <TouchableOpacity
        style={{
          position: "absolute",
          top: 8,
          right: 20,
          paddingHorizontal: 16,
          paddingVertical: 12,
          borderRadius: 20,
          backgroundColor: isInputMode ? "#ff6b6b" : "#50cebb",
          justifyContent: "center",
          alignItems: "center",
          shadowColor: "#000",
          shadowOffset: { width: 0, height: 4 },
          shadowOpacity: 0.3,
          shadowRadius: 8,
          elevation: 8,
          zIndex: 1000,
          minWidth: 80,
        }}
        onPress={toggleInputMode}
      >
        <Text
          style={{
            color: "#fff",
            fontSize: 13,
            fontWeight: "600",
            textAlign: "center",
          }}
        >
          {isInputMode ? "Î∂ÑÏÑùÍ≤∞Í≥º" : "AIÎ∂ÑÏÑù"}
        </Text>
      </TouchableOpacity>
    </View>
  );

  // üÜï Í∞úÏÑ†Îêú hasAnalysisToday Ìï®Ïàò
  const hasAnalysisToday = async () => {
    try {
      const today = format(new Date(), "yyyy-MM-dd");
      const recentResults = await getRecentAnalysisResults(1);
      const todayAnalysis = recentResults.some(
        (result) => result.date === today
      );

      console.log(
        `üìä Ïò§Îäò(${today}) Î∂ÑÏÑù Ïó¨Î∂Ä Ï≤¥ÌÅ¨:`,
        todayAnalysis ? "Î∂ÑÏÑùÏôÑÎ£å" : "Î∂ÑÏÑùÍ∞ÄÎä•"
      );
      return todayAnalysis;
    } catch (error) {
      console.error("Ïò§Îäò Î∂ÑÏÑù ÌôïÏù∏ Ïò§Î•ò:", error);
      return false;
    }
  };

  return (
    <View style={{ flex: 1, backgroundColor: "#ffffff" }}>
      <StatusBar style="dark" backgroundColor="#ffffff" translucent={false} />

      <SafeAreaView
        style={{
          flex: 1,
          paddingTop: Platform.OS === "android" ? 35 : 0,
        }}
      >
        {isStarted && (
          <View
            style={{
              flexDirection: "row",
              alignItems: "center",
              paddingHorizontal: 16,
              paddingVertical: 12,
              borderBottomWidth: 1,
              borderBottomColor: "#eee",
            }}
          >
            <Ionicons name="sparkles" size={24} color="#50cebb" />
            <Text
              style={{
                fontSize: 18,
                fontWeight: "600",
                color: "#333",
                marginLeft: 8,
                flex: 1,
              }}
            >
              {isCollectingProfile
                ? "AI ÏΩîÏπò ÏÑ§Ï†ï Ï§ë..."
                : showAnalysisScreen && userContext
                ? `${userContext.name}ÎãòÏùò AI Î∂ÑÏÑù`
                : userContext
                ? `${userContext.name}ÎãòÏùò AI ÏΩîÏπò`
                : "AI ÎßûÏ∂§ ÌîºÎìúÎ∞±"}
            </Text>

            {userContext && !isCollectingProfile && (
              <TouchableOpacity
                style={{
                  marginRight: 8,
                  padding: 8,
                  borderRadius: 20,
                  backgroundColor: "#f8f9fa",
                }}
                onPress={() => setShowProfileScreen(true)}
              >
                <Ionicons name="settings-outline" size={20} color="#666" />
              </TouchableOpacity>
            )}

            {userContext && showAnalysisScreen && (
              <Text style={{ fontSize: 12, color: "#999" }}>
                {hasAnalyzedToday ? "ÏÇ¨Ïö©ÏôÑÎ£å" : "AI Î∂ÑÏÑù"}
              </Text>
            )}
          </View>
        )}

        {!isStarted
          ? renderStartScreen()
          : showProfileScreen
          ? renderProfileScreen()
          : isCollectingProfile
          ? renderProfileSetupScreen()
          : showAnalysisScreen
          ? renderAnalysisScreen()
          : null}
      </SafeAreaView>
    </View>
  );
};

export default AIFeedbackScreen;
